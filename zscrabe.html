<!-- # ------------------ DASHBOARDS ------------------
@app.route("/mentordashboard", methods=["GET", "POST"])
def mentordashboard():
    if "email" not in session or session.get("user_type") != "1":  # Only mentors
        return redirect(url_for("signin"))

    # Fetch current mentor
    mentor = User.query.filter_by(email=session["email"]).first()
    if not mentor:
        flash("Mentor profile not found.", "error")
        return redirect(url_for("signin"))

    # Fetch incoming mentorship requests for this mentor
    incoming_requests = MentorshipRequest.query.filter_by(
        mentor_id=mentor.id
    ).all()

    # Debug: Print the number of requests found
    print(f"DEBUG: Found {len(incoming_requests)} incoming requests for mentor {mentor.id}")
    
    # Debug: Print details of each request
    for req in incoming_requests:
        print(f"DEBUG: Request ID {req.id}, Status: {req.mentor_status}, Mentee: {req.mentee.name if req.mentee else 'None'}")

    # Fetch all mentees for the "Find Mentees" section
    query = MenteeProfile.query.join(User, MenteeProfile.user_id == User.id)
    
    # Handle search and filtering
    search_query = request.args.get("search", "").lower()
    stream_filter = request.args.get("stream", "")
    school_filter = request.args.get("school", "")
    goal_filter = request.args.get("goal", "")

    if search_query:
        query = query.filter(
            or_(
                User.name.ilike(f"%{search_query}%"),
                MenteeProfile.stream.ilike(f"%{search_query}%"),
                MenteeProfile.school_college_name.ilike(f"%{search_query}%")
            )
        )
    if stream_filter:
        query = query.filter(MenteeProfile.stream == stream_filter)
    if school_filter:
        query = query.filter(MenteeProfile.school_college_name == school_filter)
    if goal_filter:
        query = query.filter(MenteeProfile.goal == goal_filter)

    all_mentees = query.all()

    # Get dropdown options
    streams = sorted({m.stream for m in MenteeProfile.query.distinct() if m.stream})
    schools = sorted({m.school_college_name for m in MenteeProfile.query.distinct() if m.school_college_name})
    goals = sorted({m.goal for m in MenteeProfile.query.distinct() if m.goal})

    # Mentor profile info
    mentor_info = {
        "full_name": mentor.name,
        "username": mentor.email,
        "date_time": datetime.now().strftime("%d-%m-%Y %H:%M:%S")
    }

    # Determine which section to show (default to dashboard, but can be overridden)
    active_section = request.args.get("section", "dashboard")
    
    return render_template(
        "mentordashboard.html",
        incoming_requests=incoming_requests,  # Make sure this is passed
        mentorship_requests=incoming_requests,  # Also pass as mentorship_requests for compatibility
        all_mentees=all_mentees,
        streams=streams,
        schools=schools,
        goals=goals,
        mentor_info=mentor_info,
        active_section=active_section,  # This controls which section is shown
        show_sidebar=True
    )


























    
@app.route("/find_mentees", methods=["GET"])
def find_mentees():
    if "email" not in session or session.get("user_type") != "1":  # Only mentors can access
        return redirect(url_for("signin"))

    # Base query
    query = MenteeProfile.query.join(User, MenteeProfile.user_id == User.id)

    # Filters
    search_query = request.args.get("search", "").lower()
    stream_filter = request.args.get("stream", "")
    school_filter = request.args.get("school", "")
    goal_filter = request.args.get("goal", "")

    if search_query:
        query = query.filter(
            or_(
                User.name.ilike(f"%{search_query}%"),
                MenteeProfile.stream.ilike(f"%{search_query}%"),
                MenteeProfile.school_college_name.ilike(f"%{search_query}%")
            )
        )

    if stream_filter:
        query = query.filter(MenteeProfile.stream == stream_filter)
    if school_filter:
        query = query.filter(MenteeProfile.school_college_name == school_filter)
    if goal_filter:
        query = query.filter(MenteeProfile.goal == goal_filter)

    filtered_mentees = query.all()

    # Get filter options directly
    streams = sorted({m.stream for m in MenteeProfile.query.with_entities(MenteeProfile.stream).distinct() if m.stream})
    schools = sorted({m.school_college_name for m in MenteeProfile.query.with_entities(MenteeProfile.school_college_name).distinct() if m.school_college_name})
    goals = sorted({m.goal for m in MenteeProfile.query.with_entities(MenteeProfile.goal).distinct() if m.goal})

    return render_template(
        "mentordashboard.html",
        all_mentees=filtered_mentees,
        streams=streams,
        schools=schools,
        goals=goals,
        active_section="findmentees",
        show_sidebar=True
    )




























@app.route("/mentordashboard", methods=["GET", "POST"])
def mentordashboard():
    if "email" not in session or session.get("user_type") != "1":  # Only mentors
        return redirect(url_for("signin"))

    # Fetch current mentor
    mentor = User.query.filter_by(email=session["email"]).first()
    if not mentor:
        flash("Mentor profile not found.", "error")
        return redirect(url_for("signin"))

    # Fetch incoming mentorship requests for this mentor
    incoming_requests = MentorshipRequest.query.filter_by(
        mentor_id=mentor.id
    ).all()

    # Debug: Print the number of requests found
    print(f"DEBUG: Found {len(incoming_requests)} incoming requests for mentor {mentor.id}")
    
    # Debug: Print details of each request
    for req in incoming_requests:
        print(f"DEBUG: Request ID {req.id}, Status: {req.mentor_status}, Mentee: {req.mentee.name if req.mentee else 'None'}")

    # Fetch all mentees for the "Find Mentees" section
    query = MenteeProfile.query.join(User, MenteeProfile.user_id == User.id)
    
    # Handle search and filtering
    search_query = request.args.get("search", "").lower()
    stream_filter = request.args.get("stream", "")
    school_filter = request.args.get("school", "")
    goal_filter = request.args.get("goal", "")

    if search_query:
        query = query.filter(
            or_(
                User.name.ilike(f"%{search_query}%"),
                MenteeProfile.stream.ilike(f"%{search_query}%"),
                MenteeProfile.school_college_name.ilike(f"%{search_query}%")
            )
        )
    if stream_filter:
        query = query.filter(MenteeProfile.stream == stream_filter)
    if school_filter:
        query = query.filter(MenteeProfile.school_college_name == school_filter)
    if goal_filter:
        query = query.filter(MenteeProfile.goal == goal_filter)

    all_mentees = query.all()

    # Get dropdown options
    streams = sorted({m.stream for m in MenteeProfile.query.distinct() if m.stream})
    schools = sorted({m.school_college_name for m in MenteeProfile.query.distinct() if m.school_college_name})
    goals = sorted({m.goal for m in MenteeProfile.query.distinct() if m.goal})

    # Mentor profile info
    mentor_info = {
        "full_name": mentor.name,
        "username": mentor.email,
        "date_time": datetime.now().strftime("%d-%m-%Y %H:%M:%S")
    }

    # Determine which section to show (default to dashboard, but can be overridden)
    active_section = request.args.get("section", "dashboard")
    
    return render_template(
        "mentordashboard.html",
        incoming_requests=incoming_requests,  # Make sure this is passed
        mentorship_requests=incoming_requests,  # Also pass as mentorship_requests for compatibility
        all_mentees=all_mentees,
        streams=streams,
        schools=schools,
        goals=goals,
        mentor_info=mentor_info,
        active_section=active_section,  # This controls which section is shown
        show_sidebar=True
    )

























     -->




















     <!-- app.py -->



     from flask import Flask, redirect, url_for, render_template, request, session, flash, jsonify
from datetime import timedelta
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin, login_user, LoginManager, login_required, logout_user, current_user
from sqlalchemy import cast, Integer
from werkzeug.security import generate_password_hash, check_password_hash
import os
from werkzeug.utils import secure_filename
from datetime import datetime
from functools import wraps
from sqlalchemy import or_





app = Flask(__name__)
app.secret_key = "1234"
app.permanent_session_lifetime = timedelta(days=10)

# Image upload configuration
UPLOAD_FOLDER = "static/uploads"
ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}

app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

# Ensure folder exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS



login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = "signin" 

# --- User Loader ---
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


#--------------User_type Code------------------------
# -------------supervisor = "0"----------------------
# -------------mentor = "1"--------------------------
# -------------mantee = "2"--------------------------

#---------------DATABASE CONFIGURATION----------------

# db_url = os.getenv("DATABASE_URL", "sqlite:///mentors_connect.db")

# #render gives 'postgres://' but SQLAlchemy needs 'postgresql://'
# if db_url.startswith("postgres://"):
#     db_url = db_url.replace("postgres://", "postgresql://", 1)

# app.config["SQLALCHEMY_DATABASE_URI"] = db_url
# app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

app.config["SQLALCHEMY_DATABASE_URI"] ="sqlite:///mentors_connect.db"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False


db = SQLAlchemy(app)

from flask_migrate import Migrate
migrate = Migrate(app, db)




def mentor_login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if session.get("user_type") != "1":
            flash("Please login as mentor first!", "error")
            return redirect(url_for("signin"))
        return f(*args, **kwargs)
    return decorated_function



#--------------USER MODEL----------------
class User(db.Model):
    __tablename__ = "signup_details"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)   # length thoda bada
    user_type = db.Column(db.String(10), nullable=False)

    #connect form another table
    mentor_profile = db.relationship("MentorProfile", backref="user", uselist=False)

    def __repr__(self):
        return f"<user {self.name}>"


#------------table mentors details-------------------

class MentorProfile(db.Model):
    __tablename__="mentor_profile"

    id = db.Column(db.Integer, primary_key=True)

    # foregin key link to User table
    user_id= db.Column(db.Integer, db.ForeignKey("signup_details.id"),nullable=False)

    #  mentor's details
    profession = db.Column(db.String(100))
    organisation = db.Column(db.String(150))
    whatsapp = db.Column(db.String(20))
    location = db.Column(db.String(100))
    education = db.Column(db.String(150))
    language = db.Column(db.String(100))
    availability = db.Column(db.String(100))
    connect_frequency = db.Column(db.String(100))
    preferred_communication = db.Column(db.String(100))
    social_link = db.Column(db.String(200))
    why_mentor = db.Column(db.Text)
    additional_info = db.Column(db.Text)
    profile_picture = db.Column(db.String(100)) 
    years_of_experience = db.Column(db.String(100))     
    status = db.Column(db.String(20), default="pending") 





#------------next table mentee details-------------------
class MenteeProfile(db.Model):
    __tablename__ = "mentee_profile"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("signup_details.id"), nullable=False)

    # mentee details
    dob = db.Column(db.String(20))
    school_college_name = db.Column(db.String(150))
    mobile_number = db.Column(db.String(20))
    whatsapp_number = db.Column(db.String(20))
    govt_private = db.Column(db.String(50))
    stream = db.Column(db.String(100))
    class_year = db.Column(db.String(50))
    favourite_subject = db.Column(db.String(100))
    goal = db.Column(db.Text)

    # parent info
    parent_name = db.Column(db.String(150))
    parent_mobile = db.Column(db.String(20))

    # other
    comments = db.Column(db.Text)
    terms_agreement = db.Column(db.String(10))  # Yes / No
    profile_picture = db.Column(db.String(100))  # store image filename
    status = db.Column(db.String(20), default="pending")  # Add this
    user = db.relationship("User", backref="mentee_profile", uselist=False)


#------------next table supervisor details-------------------
class SupervisorProfile(db.Model):
    __tablename__ = "supervisor_profile"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("signup_details.id"), nullable=False, unique=True)



    organisation = db.Column(db.String(150))
    whatsapp = db.Column(db.String(20))
    location = db.Column(db.String(100))
    role = db.Column(db.String(100))
    additional_info = db.Column(db.Text)
    profile_picture = db.Column(db.String(100))

    # One-to-one relationship with User
    user = db.relationship("User", backref="supervisor_profile", uselist=False)


# -----------get mentee deatls for mentor when request comes----------------
@app.route("/get_mentee_details/<int:request_id>", methods=["GET"])
@login_required
def get_mentee_details(request_id):
    # Ensure the logged-in user is a mentor and the request is for them
    if session.get("user_type") != "1":
        return jsonify({"error": "Unauthorized access."}), 403

    # Fetch the mentorship request
    mentorship_request = MentorshipRequest.query.get(request_id)
    if not mentorship_request:
        return jsonify({"error": "Request not found."}), 404

    # Fetch mentee's details using the relationships
    mentee_user = mentorship_request.mentee.user
    mentee_profile = mentorship_request.mentee.mentee_profile

    if not mentee_user or not mentee_profile:
        return jsonify({"error": "Mentee details not found."}), 404

    # Construct the data to be returned as JSON
    mentee_data = {
        "name": mentee_user.name,
        "email": mentee_user.email,
        "stream": mentee_profile.stream,
        "school": mentee_profile.school_college_name,
        "contact": mentee_profile.whatsapp_number,
        "goal": mentee_profile.goal,
        "purpose": mentorship_request.why_need_mentor
    }

    return jsonify(mentee_data)


#------------------mentorship request table-------------------
class MentorshipRequest(db.Model):
    __tablename__ = "mentorship_requests"
    id = db.Column(db.Integer, primary_key=True)
    mentee_id = db.Column(db.Integer, db.ForeignKey("signup_details.id"), nullable=False)
    mentor_id = db.Column(db.Integer, db.ForeignKey("signup_details.id"), nullable=False)
    status = db.Column(db.String(20), default="pending") 
    # Details from the form
    meeting_time = db.Column(db.String(50), nullable=False)
    timezone = db.Column(db.String(100))
    meeting_type = db.Column(db.String(50)) # 'special' or 'anchor'
    purpose_type = db.Column(db.String(50)) # 'long' or 'short'
    why_need_mentor = db.Column(db.Text, nullable=False)
    
    # Request status tracking
    mentor_status = db.Column(db.String(20), default="pending") # 'pending', 'accepted', 'rejected'
    supervisor_status = db.Column(db.String(20), default="pending") # 'pending', 'approved', 'rejected'
    final_status = db.Column(db.String(20), default="pending") # 'pending', 'approved', 'rejected'

    
    # Relationships for easy access
    mentee = db.relationship("User", foreign_keys=[mentee_id], backref="sent_requests")
    mentor = db.relationship("User", foreign_keys=[mentor_id], backref="received_requests")







#-------------HOME----------------
@app.route("/")
def home():
    return render_template("index.html")


#--------------SIGNUP----------------
@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        name = request.form.get("name")
        email = request.form.get("email")
        password = request.form.get("password")
        user_type = request.form.get("user_type")

        # Basic validation
        if not name or not email or not password or not user_type:
            flash("All fields are required.", "error")
            return render_template("signup.html")
        
        # Check for existing user
        if User.query.filter_by(email=email).first():
            flash("Email already registered.", "error")
            return render_template("signup.html")

        # Hash password
        hashed_password = generate_password_hash(password)
        new_user = User(name=name, email=email, password=hashed_password, user_type=user_type)
        db.session.add(new_user)
        db.session.commit()
        flash("Signup successful! Please sign in.", "success")
        return redirect(url_for("signin"))

    return render_template("signup.html")
#--------------SIGNIN----------------

@app.route("/signin", methods=["GET"])
def signin():
    if request.method == "POST":
        session.permanent = True
        email = request.form["email"]
        password = request.form["password"]

        # fetch user from "database"
        user = User.query.filter_by(email=email).first()

        # Check if user exists
        if not user:
            return "User not found! Please sign up first."

        # Check password
        if not check_password_hash(user.password, password):
            return "Incorrect password!"

        # Save session
        session["email"] = user.email
        session["user_type"] = user.user_type

        # Redirect based on role
        if user.user_type == "1":
            return redirect(url_for("mentordashboard"))
        elif user.user_type == "2":
            return redirect(url_for("menteedashboard"))
        elif user.user_type == "0":
            return redirect(url_for("supervisordashboard"))
        
        
        
        return redirect(url_for("home"))

   
    return render_template("signin.html")



# ------------------ DASHBOARDS ------------------

@app.route("/mentordashboard", methods=["GET", "POST"])
def mentordashboard():
    if "email" not in session or session.get("user_type") != "1":  # Only mentors
        return redirect(url_for("signin"))

    mentor_id = session.get("user_id")

    # ------------------- mentee requests -------------------
            # Fetch current mentor
    mentor = User.query.filter_by(email=session["email"]).first()

    if not mentor:
            flash("Mentor profile not found.", "error")
            return redirect(url_for("signin"))

        # Fetch incoming mentorship requests for this mentor
    incoming_requests = MentorshipRequest.query.filter_by(
            mentor_id=mentor.id
        ).all()

        # Fetch all mentees
    all_mentees = MenteeProfile.query.all()

        # Unique filter values from mentees
    streams = [row.stream for row in MenteeProfile.query.with_entities(MenteeProfile.stream).distinct() if row.stream]
    schools = [row.school_college_name for row in MenteeProfile.query.with_entities(MenteeProfile.school_college_name).distinct() if row.school_college_name]
    goals = [row.goal for row in MenteeProfile.query.with_entities(MenteeProfile.goal).distinct() if row.goal]

        # Get a specific mentee for the profile section (if needed)
        # For example, get the first mentee from the requests if available
    example_mentee = None
    if incoming_requests and incoming_requests[0].mentee:
            example_mentee = incoming_requests[0].mentee

        # Mentor profile info
    mentor_info = {
            "full_name": mentor.name,  # Use .name if that's your column
            "username": mentor.email,
            "date_time": datetime.now().strftime("%d-%m-%Y %H:%M:%S")
        }



    # ------------------- find mentees (with filters) -------------------
    query = MenteeProfile.query.join(User, MenteeProfile.user_id == User.id)

    search_query = request.args.get("search", "").lower()
    stream_filter = request.args.get("stream", "")
    school_filter = request.args.get("school", "")
    goal_filter = request.args.get("goal", "")

    if search_query:
        query = query.filter(
            or_(
                User.name.ilike(f"%{search_query}%"),
                MenteeProfile.stream.ilike(f"%{search_query}%"),
                MenteeProfile.school_college_name.ilike(f"%{search_query}%")
            )
        )
    if stream_filter:
        query = query.filter(MenteeProfile.stream == stream_filter)
    if school_filter:
        query = query.filter(MenteeProfile.school_college_name == school_filter)
    if goal_filter:
        query = query.filter(MenteeProfile.goal == goal_filter)

    all_mentees = query.all()

    # dropdown options
    streams = sorted({m.stream for m in MenteeProfile.query.distinct() if m.stream})
    schools = sorted({m.school_college_name for m in MenteeProfile.query.distinct() if m.school_college_name})
    goals = sorted({m.goal for m in MenteeProfile.query.distinct() if m.goal})

    return render_template(
        "mentordashboard.html",
        mentorship_requests=incoming_requests,
        all_mentees=all_mentees,
        streams=streams,
        schools=schools,
        goals=goals,
        incoming_requests=incoming_requests,
        mentor_info=mentor_info,
        active_section="dashboard",
        show_sidebar=True,
        mentee=example_mentee
    )




@app.route("/menteedashboard")
def menteedashboard():
    if "email" in session and session.get("user_type") == "2":
        # Fetch current mentee
        user = User.query.filter_by(email=session["email"]).first()



        all_mentors = MentorProfile.query.filter_by().all()

        # unique filter value from db
        professions = [row.profession for row in MentorProfile.query.with_entities(MentorProfile.profession).distinct() if row]
        locations = [row.location for row in MentorProfile.query.with_entities(MentorProfile.location).distinct() if row.location]
        educations = [row.education for row in MentorProfile.query.with_entities(MentorProfile.education).distinct() if row.education]
        experiences = [row.years_of_experience for row in MentorProfile.query.with_entities(MentorProfile.years_of_experience).distinct() if row.years_of_experience]


        # Optionally, fetch mentors already assigned to this mentee
        # This depends if you have a "mentorship" table, for now we just show all mentors
    
        return render_template(
            "menteedashboard.html",
            all_mentors=all_mentors,
            professions=[row.profession for row in MentorProfile.query.with_entities(MentorProfile.profession).distinct() if row.profession],
            locations=[row.location for row in MentorProfile.query.with_entities(MentorProfile.location).distinct() if row.location],
            educations=[row.education for row in MentorProfile.query.with_entities(MentorProfile.education).distinct() if row.education],
            experiences=[row.years_of_experience for row in MentorProfile.query.with_entities(MentorProfile.years_of_experience).distinct() if row.years_of_experience],
            active_section="findmentor",
            show_sidebar=True
        )




    return redirect(url_for("signin"))



@app.route("/supervisordashboard")
def supervisordashboard():
    if "email" in session and session.get("user_type") == "0":
        # Fetch all mentors and mentees
        mentors = MentorProfile.query.all()
        mentees = MenteeProfile.query.all()

        # Fetch all mentorship requests
        all_requests = MentorshipRequest.query.all()
        
        # Fetch pending mentor and mentee profile approvals
        mentor_requests = MentorProfile.query.filter_by(status="pending").all()
        mentee_requests = MenteeProfile.query.filter_by(status="pending").all()

        return render_template(
            "supervisordashboard.html",
            show_sidebar=True,
            user_email=session["email"],
            mentors=mentors,
            mentees=mentees,
            all_requests=all_requests,
            mentor_requests=mentor_requests,
            mentee_requests=mentee_requests,
            active_section="dashboard"
        )
    return redirect(url_for("signin"))


@app.route("/find_mentees", methods=["GET"])
def find_mentees():
    if "email" not in session or session.get("user_type") != "1":  # Only mentors can access
        return redirect(url_for("signin"))

    # Base query
    query = MenteeProfile.query.join(User, MenteeProfile.user_id == User.id)

    # Filters
    search_query = request.args.get("search", "").lower()
    stream_filter = request.args.get("stream", "")
    school_filter = request.args.get("school", "")
    goal_filter = request.args.get("goal", "")

    if search_query:
        query = query.filter(
            or_(
                User.name.ilike(f"%{search_query}%"),
                MenteeProfile.stream.ilike(f"%{search_query}%"),
                MenteeProfile.school_college_name.ilike(f"%{search_query}%")
            )
        )

    if stream_filter:
        query = query.filter(MenteeProfile.stream == stream_filter)
    if school_filter:
        query = query.filter(MenteeProfile.school_college_name == school_filter)
    if goal_filter:
        query = query.filter(MenteeProfile.goal == goal_filter)

    filtered_mentees = query.all()

    # Get filter options directly
    streams = sorted({m.stream for m in MenteeProfile.query.with_entities(MenteeProfile.stream).distinct() if m.stream})
    schools = sorted({m.school_college_name for m in MenteeProfile.query.with_entities(MenteeProfile.school_college_name).distinct() if m.school_college_name})
    goals = sorted({m.goal for m in MenteeProfile.query.with_entities(MenteeProfile.goal).distinct() if m.goal})

    return render_template(
        "mentordashboard.html",
        all_mentees=filtered_mentees,
        streams=streams,
        schools=schools,
        goals=goals,
        active_section="findmentees",
        show_sidebar=True
    )



# ------------------- HANDLE MENTORSHIP REQUEST ------------------
@app.route("/request_mentorship", methods=["POST"])
def request_mentorship():
    if "email" not in session or session.get("user_type") != "2":
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        data = request.json
        mentor_id = data.get("mentor_id")
        meeting_time = data.get("meeting_time")
        timezone = data.get("timezone")
        meeting_type = data.get("meeting_type")
        purpose_type = data.get("purpose_type")
        why_need_mentor = data.get("why_need_mentor")

        if not all([mentor_id, meeting_time, why_need_mentor]):
            return jsonify({"success": False, "message": "Missing required fields"}), 400

        mentee = User.query.filter_by(email=session["email"]).first()
        
        new_request = MentorshipRequest(
            mentee_id=mentee.id,
            mentor_id=mentor_id,
            meeting_time=meeting_time,
            timezone=timezone,
            meeting_type=meeting_type,
            purpose_type=purpose_type,
            why_need_mentor=why_need_mentor
        )
        db.session.add(new_request)
        db.session.commit()

        return jsonify({"success": True, "message": "Mentorship request sent successfully!"}), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({"success": False, "message": str(e)}), 500


@app.route("/mentor_response", methods=["POST"])
def mentor_response():
    # Get form data
    request_id = request.form.get("request_id")
    action = request.form.get("action")

    if not request_id or not action:
        flash("Invalid request!", "error")
        return redirect(url_for("mentordashboard"))

    # Fetch mentorship request
    mentorship_request = MentorshipRequest.query.get(int(request_id))
    if not mentorship_request:
        flash("Request not found!", "error")
        return redirect(url_for("mentordashboard"))

    # Ensure mentor is logged in
    mentor = None
    if "email" in session and session.get("user_type") == "1":
        mentor = User.query.filter_by(email=session["email"]).first()

    if not mentor or mentorship_request.mentor_id != mentor.id:
        flash("This is not your request or you are not logged in as mentor!", "error")
        return redirect(url_for("mentordashboard"))

    # Update status
    mentorship_request.mentor_status = "accepted" if action == "accept" else "rejected"

    try:
        db.session.commit()
        flash(f"Request {action}ed successfully!", "success")
    except Exception as e:
        db.session.rollback()
        flash("Something went wrong while updating the request.", "error")
        print("DB Commit Error:", e)

    # Always redirect to mentor dashboard
    return redirect(url_for("mentordashboard"))






#------------------- PROFILE PICTURE AT TOP ------------------
@app.context_processor
def inject_user_profile_pic():
    if "email" in session:
        user = User.query.filter_by(email=session["email"]).first()
        profile_pic = None
        if user:
            if session.get("user_type") == "1":  # Mentor
                profile = MentorProfile.query.filter_by(user_id=user.id).first()
                profile_pic = profile.profile_picture if profile else None
            elif session.get("user_type") == "2":  # Mentee
                profile = MenteeProfile.query.filter_by(user_id=user.id).first()
                profile_pic = profile.profile_picture if profile else None
            elif session.get("user_type") == "0":  # Supervisor
                profile = SupervisorProfile.query.filter_by(user_id=user.id).first()
                profile_pic = profile.profile_picture if profile else None
        return dict(current_user_profile_pic=profile_pic)
    return dict(current_user_profile_pic=None)


# ------------------ LOGOUT ------------------
@app.route("/logout")
def logout():
    session.clear()   
    flash("You have been logged out!", "info")
    return redirect(url_for("signin"))



# ------------------ editmentorprofile ------------------
@app.route("/editmentorprofile", methods=["GET", "POST"])
def editmentorprofile():
    if "email" not in session or session.get("user_type") != "1":
        return redirect(url_for("signin"))

    # Current user
    user = User.query.filter_by(email=session["email"]).first()
    profile = MentorProfile.query.filter_by(user_id=user.id).first()

    if request.method == "POST":
        # Create profile if not exists
        if not profile:
            profile = MentorProfile(user_id=user.id)


        # Save form data
        profile.profession = request.form.get("profession")
        profile.organisation = request.form.get("organisation_or_college")
        profile.whatsapp = request.form.get("whatsapp_number")
        profile.location = request.form.get("location")
        profile.education = request.form.get("education")
        profile.language = request.form.get("language")
        profile.availability = request.form.get("availability_month")
        profile.connect_frequency = request.form.get("connect_frequency")
        profile.preferred_communication = request.form.get("preferred_communication")
        profile.social_link = request.form.get("social_link")
        profile.why_mentor = request.form.get("mentor_reason")
        profile.years_of_experience = request.form.get("experience")  # new field
        profile.additional_info = request.form.get("additional_info")  # optional

        # Handle profile picture upload
        file = request.files.get("profile_picture")
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # Save file to upload folder
            file.save(os.path.join(app.config["UPLOAD_FOLDER"], filename))
            #store filename in db
            profile.profile_picture = filename

        db.session.add(profile)
        db.session.commit()

        flash("Profile updated successfully!", "success")
        # Redirect to mentor profile page with data
        return redirect(url_for("mentorprofile"))

    # GET request – pre-fill form with existing data
    return render_template(
        "editmentorprofile.html",
        full_name=user.name,
        email=user.email,
        profession=profile.profession if profile else "",
        organisation_or_college=profile.organisation if profile else "",
        whatsapp_number=profile.whatsapp if profile else "",
        location=profile.location if profile else "",
        education=profile.education if profile else "",
        language=profile.language if profile else "",
        availability_month=profile.availability if profile else "",
        connect_frequency=profile.connect_frequency if profile else "",
        preferred_communication=profile.preferred_communication if profile else "",
        social_link=profile.social_link if profile else "",
        mentor_reason=profile.why_mentor if profile else "",
        additional_info=profile.additional_info if profile else "",
        experience=profile.years_of_experience if profile else "",
        profile_picture=profile.profile_picture if profile else None 
    )




#-----------------edit mentee profile-------------------
@app.route("/editmenteeprofile", methods=["GET", "POST"])
def editmenteeprofile():
    if "email" not in session or session.get("user_type") != "2":
        return redirect(url_for("signin"))

    # Current user
    user = User.query.filter_by(email=session["email"]).first()
    profile = MenteeProfile.query.filter_by(user_id=user.id).first()

    if request.method == "POST":
        # Create profile if not exists
        if not profile:
            profile = MenteeProfile(user_id=user.id)

        # Save form data
        profile.dob = request.form.get("dob")
        profile.school_college_name = request.form.get("school_college_name")
        profile.mobile_number = request.form.get("mobile_number")
        profile.whatsapp_number = request.form.get("whatsapp_number")
        profile.govt_private = request.form.get("govt_private")
        profile.stream = request.form.get("stream")
        profile.class_year = request.form.get("class_year")
        profile.favourite_subject = request.form.get("favourite_subject")
        profile.goal = request.form.get("goal")
        profile.parent_name = request.form.get("parent_name")
        profile.parent_mobile = request.form.get("parent_mobile")
        profile.comments = request.form.get("comments")
        profile.terms_agreement = request.form.get("terms_agreement")

        # Handle profile picture upload
        file = request.files.get("profile_picture")
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # Save file to upload folder
            file.save(os.path.join(app.config["UPLOAD_FOLDER"], filename))
            # Store filename in db
            profile.profile_picture = filename

        db.session.add(profile)
        db.session.commit()

        flash("Mentee profile updated successfully!", "success")
        # Redirect to mentee profile page
        return redirect(url_for("menteeprofile"))

    # GET request – pre-fill form with existing data
    return render_template(
        "editmenteeprofile.html",
        full_name=user.name,
        email=user.email,
        dob=profile.dob if profile else "",
        school_college_name=profile.school_college_name if profile else "",
        mobile_number=profile.mobile_number if profile else "",
        whatsapp_number=profile.whatsapp_number if profile else "",
        govt_private=profile.govt_private if profile else "",
        stream=profile.stream if profile else "",
        class_year=profile.class_year if profile else "",
        favourite_subject=profile.favourite_subject if profile else "",
        goal=profile.goal if profile else "",
        parent_name=profile.parent_name if profile else "",
        parent_mobile=profile.parent_mobile if profile else "",
        comments=profile.comments if profile else "",
        terms_agreement=profile.terms_agreement if profile else "",
        profile_picture=profile.profile_picture if profile else None
    )


#----------------edit supervisor profile-------------------
@app.route("/edit_supervisor_profile", methods=["GET", "POST"])
def editsupervisorprofile():
    if "email" not in session or session.get("user_type") != "0":  
        return redirect(url_for("signin"))

    user = User.query.filter_by(email=session["email"]).first()
    profile = SupervisorProfile.query.filter_by(user_id=user.id).first()

    if request.method == "POST":
        if not profile:
            profile = SupervisorProfile(user_id=user.id)
            db.session.add(profile)

        profile.organisation = request.form.get("organisation_or_college")
        profile.whatsapp = request.form.get("whatsapp_number")
        profile.location = request.form.get("location")
        profile.role = request.form.get("role")
        profile.additional_info = request.form.get("additional_info")

        # Profile picture handling
        file = request.files.get("profile_picture")
        if file and allowed_file(file.filename):
            filename = f"{user.id}_{int(datetime.now().timestamp())}{secure_filename(file.filename)}"
            file.save(os.path.join(app.config["UPLOAD_FOLDER"], filename))
            profile.profile_picture = filename
        db.session.add(profile)
        db.session.commit()
        flash("Profile updated successfully!", "success")
        return redirect(url_for("supervisorprofile"))

    return render_template(
        "editsupervisorprofile.html",
        full_name=user.name,
        email=user.email,
        organisation_or_college=profile.organisation if profile else "",
        whatsapp_number=profile.whatsapp if profile else "",
        location=profile.location if profile else "",
        role=profile.role if profile else "",
        additional_info=profile.additional_info if profile else "",
        profile_picture=profile.profile_picture if profile else None
    )


# ------------------ PROFILE ------------------

@app.route("/profile")
def profile():
    if "email" not in session:
        return redirect(url_for("signin"))

    user_type = session.get("user_type")
    
    if user_type == "1":
        return redirect(url_for("mentorprofile"))
    elif user_type == "2":
        return redirect(url_for("menteeprofile"))
    elif user_type == "0":
        return redirect(url_for("supervisorprofile"))

#--------------route for all profiles----------------

@app.route("/mentor_profile")
def mentorprofile(): 
    if "email" in session and session.get("user_type") == "1":
        # Fetch current user
        user = User.query.filter_by(email=session["email"]).first()
        profile = MentorProfile.query.filter_by(user_id=user.id).first()

        return render_template(
            "mentorprofile.html",
            show_sidebar=False,
            full_name=user.name,
            email=user.email,
            profession=profile.profession if profile else "",
            organisation_or_college=profile.organisation if profile else "",
            whatsapp_number=profile.whatsapp if profile else "",
            location=profile.location if profile else "",
            education=profile.education if profile else "",
            language=profile.language if profile else "",
            availability_month=profile.availability if profile else "",
            connect_frequency=profile.connect_frequency if profile else "",
            preferred_communication=profile.preferred_communication if profile else "",
            social_link=profile.social_link if profile else "",
            mentor_reason=profile.why_mentor if profile else "",
            additional_info=profile.additional_info if profile else "",
            experience=profile.years_of_experience if profile else "",
            profile_picture=profile.profile_picture if profile else None
        )
    return redirect(url_for("signin"))


from datetime import datetime

@app.route("/mentee_profile")
def menteeprofile():
    if "email" in session and session.get("user_type") == "2":
        user = User.query.filter_by(email=session["email"]).first()
        profile = MenteeProfile.query.filter_by(user_id=user.id).first()

        dob_formatted = ""
        if profile and profile.dob:
            try:
                # Assume dob stored as yyyy-mm-dd (from HTML <input type="date">)
                dob_formatted = datetime.strptime(profile.dob, "%Y-%m-%d").strftime("%d-%m-%Y")
            except ValueError:
                dob_formatted = profile.dob   # fallback if already formatted

        return render_template(
            "menteeprofile.html",
            show_sidebar=False,
            full_name=user.name,
            email=user.email,
            dob=dob_formatted,
            school_college_name=profile.school_college_name if profile else "",
            mobile_number=profile.mobile_number if profile else "",
            whatsapp_number=profile.whatsapp_number if profile else "",
            govt_private=profile.govt_private if profile else "",
            stream=profile.stream if profile else "",
            class_year=profile.class_year if profile else "",
            favourite_subject=profile.favourite_subject if profile else "",
            goal=profile.goal if profile else "",
            parent_name=profile.parent_name if profile else "",
            parent_mobile=profile.parent_mobile if profile else "",
            comments=profile.comments if profile else "",
            terms_agreement=profile.terms_agreement if profile else "",
            profile_picture=profile.profile_picture if profile else None
        )
    return redirect(url_for("signin"))



@app.route("/supervisor_profile")
def supervisorprofile():
    # Ensure user is logged in and is a supervisor
    if "email" not in session or session.get("user_type") != "0":
        return redirect(url_for("signin"))

    # Fetch current user
    user = User.query.filter_by(email=session["email"]).first()
    if not user:
        return redirect(url_for("signin"))

    # Fetch supervisor profile
    profile = SupervisorProfile.query.filter_by(user_id=user.id).first()

    return render_template(
        "supervisorprofile.html",
        show_sidebar=False,
        full_name=user.name,
        email=user.email,
        organisation_or_college=profile.organisation if profile else "",
        whatsapp_number=profile.whatsapp if profile else "",
        location=profile.location if profile else "",
        role=profile.role if profile else "",
        additional_info=profile.additional_info if profile else "",
        profile_picture=profile.profile_picture if profile else None
    )


# ------------------ APPROVE/REJECT MENTORSHIP REQUESTS ------------------
@app.route("/supervisor_response", methods=["POST"])
def supervisor_response():
    if "email" not in session or session.get("user_type") != "0":
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    request_id = request.form.get("request_id")
    action = request.form.get("action")
    
    if not request_id or not action:
        flash("Invalid request!", "error")
        return redirect(url_for("supervisordashboard"))
    
    # Fetch mentorship request
    mentorship_request = MentorshipRequest.query.get(int(request_id))
    if not mentorship_request:
        flash("Request not found!", "error")
        return redirect(url_for("supervisordashboard"))
    
    # Update status based on action
    if action == "approve":
        mentorship_request.supervisor_status = "approved"
        mentorship_request.final_status = "approved"
        flash("Mentorship request approved!", "success")
    elif action == "reject":
        mentorship_request.supervisor_status = "rejected"
        mentorship_request.final_status = "rejected"
        flash("Mentorship request rejected!", "success")
    else:
        flash("Invalid action!", "error")
        return redirect(url_for("supervisordashboard"))
    
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        flash("Something went wrong while updating the request.", "error")
        print("DB Commit Error:", e)
    
    return redirect(url_for("supervisordashboard"))

# ------------------ APPROVE/REJECT PROFILE REQUESTS ------------------
@app.route("/approve_profile", methods=["POST"])
def approve_profile():
    if "email" not in session or session.get("user_type") != "0":
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    profile_type = request.form.get("profile_type")
    profile_id = request.form.get("profile_id")
    action = request.form.get("action")
    
    if not all([profile_type, profile_id, action]):
        flash("Invalid request!", "error")
        return redirect(url_for("supervisordashboard"))
    
    # Handle mentor profile approval/rejection
    if profile_type == "mentor":
        profile = MentorProfile.query.get(int(profile_id))
    elif profile_type == "mentee":
        profile = MenteeProfile.query.get(int(profile_id))
    else:
        flash("Invalid profile type!", "error")
        return redirect(url_for("supervisordashboard"))
    
    if not profile:
        flash("Profile not found!", "error")
        return redirect(url_for("supervisordashboard"))
    
    # Update status based on action
    if action == "approve":
        profile.status = "approved"
        flash(f"{profile_type.capitalize()} profile approved!", "success")
    elif action == "reject":
        profile.status = "rejected"
        flash(f"{profile_type.capitalize()} profile rejected!", "success")
    else:
        flash("Invalid action!", "error")
        return redirect(url_for("supervisordashboard"))
    
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        flash("Something went wrong while updating the profile.", "error")
        print("DB Commit Error:", e)
    
    return redirect(url_for("supervisordashboard"))

if __name__ == "__main__":
    app.run(debug=True)